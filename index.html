<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>♡awdrug♡</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: black;
      overflow: hidden;
    }
    canvas {
      position: absolute;
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
  <!-- Local font faces: place font files in `fonts/` (e.g. NotoSansMono-Regular.woff2, NotoSans-Regular.woff2) -->
  <style>
    @font-face {
      font-family: 'Noto Sans Mono Local';
      src: url('fonts/NotoSansMono-Regular.woff2') format('woff2');
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // scale factor for drawing the image (30% of original)
  const imgScale = 0.5;

  let particles = [];
  const img = new Image();
  // do not load image until user clicks Play; startScene() will set src
  const imgSrc = "stitch.png"; // image path
  img.crossOrigin = "anonymous";
  let started = false;

  // create a fullscreen overlay with a Play button; nothing runs until clicked
  const overlay = document.createElement('div');
  overlay.style.position = 'fixed';
  overlay.style.top = '0';
  overlay.style.left = '0';
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.background = 'rgba(0,0,0,0.85)';
  overlay.style.zIndex = '10000';

  // overlay canvas for 'running code' effect
  const overlayCanvas = document.createElement('canvas');
  overlayCanvas.style.position = 'absolute';
  overlayCanvas.style.top = '0';
  overlayCanvas.style.left = '0';
  overlayCanvas.style.width = '100%';
  overlayCanvas.style.height = '100%';
  overlayCanvas.width = window.innerWidth;
  overlayCanvas.height = window.innerHeight;
  overlay.appendChild(overlayCanvas);

  const ovCtx = overlayCanvas.getContext('2d');
  let cols = Math.floor(overlayCanvas.width / 16) + 1;
  const drops = new Array(cols).fill(1);
  const chars = '01{}[]()<>,.:;+-=*/\u2588█▓▒░abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let overlayAnimId = null;

  // --- Play button configuration (user-editable) ---
  // You can modify this object in the console or via window.setPlayBtnConfig({...})
  const playBtnConfig = {
    // positionMode: 'inline' (aligned under terminal) | 'free' (absolute in overlay)
    positionMode: 'free',
    // when inline: align: 'left' | 'center' | 'right'
    align: 'left',
    // additional horizontal offset in px applied as left padding inside the button wrapper (inline mode)
    offsetX: '30px',
    // additional vertical offset in px applied to the button (margin-top in inline mode)
    offsetY: 0,
    // wrapper width for terminal/button area (accepts CSS length like '70%' or '600px')
    wrapperWidth: '70%',
    // when free: CSS left/top values (can be '50%', '120px', etc.)
    freeX: '21%',
    freeY: '62%',
    // when free and anchorCenter=true the button will be centered at (freeX,freeY) using transform
    anchorCenter: true
  };

  function applyPlayBtnConfig() {
    try {
      // always apply wrapper width when termWrap exists
      if (typeof termWrap !== 'undefined' && termWrap) termWrap.style.width = playBtnConfig.wrapperWidth;

      // handle free (absolute) positioning vs inline (inside terminal area)
      if (typeof playBtn !== 'undefined' && playBtn) {
        if (playBtnConfig.positionMode === 'free') {
          // ensure playBtn is absolutely positioned inside the overlay
          playBtn.style.position = 'absolute';
          playBtn.style.left = (typeof playBtnConfig.freeX === 'number') ? (playBtnConfig.freeX + 'px') : (playBtnConfig.freeX || '50%');
          playBtn.style.top = (typeof playBtnConfig.freeY === 'number') ? (playBtnConfig.freeY + 'px') : (playBtnConfig.freeY || '50%');
          playBtn.style.marginTop = '0';
          playBtn.style.transform = playBtnConfig.anchorCenter ? 'translate(-50%, -50%)' : 'none';
          // move into overlay container so it's free to position
          if (typeof overlay !== 'undefined' && overlay && playBtn.parentElement !== overlay) {
            try { playBtn.parentElement && playBtn.parentElement.removeChild(playBtn); } catch (e) {}
            overlay.appendChild(playBtn);
          }
          // hide the inline wrapper if present
          if (typeof btnWrap !== 'undefined' && btnWrap) btnWrap.style.display = 'none';
        } else {
          // inline mode: place button back into btnWrap and use flex alignment
          playBtn.style.position = 'relative';
          playBtn.style.transform = 'none';
          playBtn.style.marginTop = (playBtnConfig.offsetY || 0) + 'px';
          if (typeof btnWrap !== 'undefined' && btnWrap) {
            btnWrap.style.display = 'flex';
            btnWrap.style.justifyContent = playBtnConfig.align === 'left' ? 'flex-start' : (playBtnConfig.align === 'right' ? 'flex-end' : 'center');
            btnWrap.style.padding = `8px 0 24px ${playBtnConfig.offsetX || 0}px`;
            if (playBtn.parentElement !== btnWrap) {
              try { playBtn.parentElement && playBtn.parentElement.removeChild(playBtn); } catch (e) {}
              btnWrap.appendChild(playBtn);
            }
          }
        }
      }
    } catch (e) {
      // ignore before elements exist
    }
  }

  // expose a helper to change config at runtime
  window.setPlayBtnConfig = function(cfg) {
    Object.assign(playBtnConfig, cfg || {});
    applyPlayBtnConfig();
    return playBtnConfig;
  };

  function overlayResize() {
    overlayCanvas.width = window.innerWidth;
    overlayCanvas.height = window.innerHeight;
    cols = Math.floor(overlayCanvas.width / 16) + 1;
    drops.length = cols;
    for (let i = 0; i < cols; i++) drops[i] = Math.floor(Math.random() * overlayCanvas.height / 16);
  }

  window.addEventListener('resize', overlayResize);

  function overlayFrame() {
    // fade the canvas a bit
    ovCtx.fillStyle = 'rgba(0,0,0,0.15)';
    ovCtx.fillRect(0, 0, overlayCanvas.width, overlayCanvas.height);

  ovCtx.fillStyle = '#34b1eb'; // blue hacker color
  ovCtx.font = '14px "Noto Sans Mono Local", "Noto Sans Local", monospace';
    for (let i = 0; i < drops.length; i++) {
      const text = chars.charAt(Math.floor(Math.random() * chars.length));
      const x = i * 16;
      const y = drops[i] * 16;
      ovCtx.fillText(text, x, y);
      if (y > overlayCanvas.height && Math.random() > 0.975) {
        drops[i] = 0;
      }
      drops[i]++;
    }
    overlayAnimId = requestAnimationFrame(overlayFrame);
  }

  const playBtn = document.createElement('button');
  playBtn.textContent = '0909';
  playBtn.setAttribute('aria-label','Play');
  playBtn.style.fontSize = '35px';
  playBtn.style.padding = '8px 12px';
  playBtn.style.borderRadius = '100px';
  playBtn.style.border = 'none';
  playBtn.style.cursor = 'pointer';
  playBtn.style.background = '#ff8fce';
  playBtn.style.color = '#fff';
  // inline positioning; will be placed inside termWrap under the terminal text
  playBtn.style.position = 'relative';
  playBtn.style.zIndex = '10002';
  playBtn.style.display = 'none'; // hidden until terminal finishes
  playBtn.onclick = startScene;
  document.body.appendChild(overlay);

  // responsive tweak: slightly smaller button on very small viewports
  function adjustBtnForViewport() {
    const w = (window.visualViewport && window.visualViewport.width) || window.innerWidth;
    if (w < 420) {
      playBtn.style.fontSize = '35px';
      playBtn.style.padding = '6px 10px';
    } else {
      playBtn.style.fontSize = '35px';
      playBtn.style.padding = '8px 12px';
    }
  }
  adjustBtnForViewport();
  window.addEventListener('resize', adjustBtnForViewport);

  // terminal-like text box on overlay
  const term = document.createElement('pre');
  term.style.position = 'relative';
  term.style.zIndex = '10001';
  term.style.width = '100%';
  term.style.maxWidth = '1920px';
  term.style.margin = '0 auto 12px';
  term.style.padding = '18px';
  term.style.background = 'rgba(0,0,0,0.6)';
  term.style.color = '#34b1eb';
  term.style.font = '30px "Noto Sans Mono Local", "Noto Sans Local", "Segoe UI Mono", "Noto Sans Mono", monospace';
  term.style.borderRadius = '6px';
  term.style.overflow = 'hidden';
  term.style.minHeight = '120px';
  term.style.maxHeight = '40vh';
  term.style.overflowY = 'auto';
  term.textContent = '';
  // insert terminal and place the button under it, left-aligned with the text
  const termWrap = document.createElement('div');
  termWrap.style.display = 'flex';
  termWrap.style.flexDirection = 'column';
  termWrap.style.alignItems = 'flex-start'; // left-align children
  termWrap.style.width = '100%';
  termWrap.style.maxWidth = '1920px';
  termWrap.style.margin = '0 auto';
  termWrap.appendChild(term);
  // small container for the button, left-aligned with the terminal text
  const btnWrap = document.createElement('div');
  btnWrap.style.width = '100%';
  btnWrap.style.display = 'flex';
  btnWrap.style.justifyContent = 'center';
  btnWrap.style.padding = '8px 0 24px 0';
  btnWrap.appendChild(playBtn);
  termWrap.appendChild(btnWrap);
  overlay.appendChild(termWrap);
  // apply any initial play button configuration
  applyPlayBtnConfig();

  // prepare fake command lines
  const terminalLines = [
    'Khởi động awdrug.exe...',
    'Đang cài đặt gói dễ thương bổ sung...',
    'Buffer năng lượng tích cực (đừng tua nha)...',
    'Cài đặt 0909.exe phiên bản vô hạn...',
    'Thêm chút xíu dễ thương awdrug...',
    'Sắp xong rồi, chờ xí...',
    'Hoàn tất! Nhấn nút thôi ❤︎...'
  ];

  // typing effect
  let tLine = 0;
  let tChar = 0;
  function typeNextChar() {
    if (tLine >= terminalLines.length) return finishTerminal();
    const line = terminalLines[tLine];
    term.textContent = terminalLines.slice(0, tLine).join('\n') + (tChar > 0 ? '\n' : '') + line.slice(0, tChar);
    tChar++;
    if (tChar > line.length) {
      // move to next line after a short pause
      tLine++;
      tChar = 0;
      setTimeout(typeNextChar, 400 + Math.random() * 300);
    } else {
      setTimeout(typeNextChar, 24 + Math.random() * 30);
    }
  }

  function finishTerminal() {
    // show play button when done
    playBtn.style.display = 'inline-block';
    // ensure it's centered and accessible
    playBtn.focus();
  }

  // start the overlay animation and terminal typing
  overlayFrame();
  setTimeout(typeNextChar, 400);

  function stopOverlay() {
    if (overlayAnimId) cancelAnimationFrame(overlayAnimId);
    try { window.removeEventListener('resize', overlayResize); } catch (e) {}
  }

  function startScene() {
    if (started) return;
    started = true;
    stopOverlay();
    try { overlay.remove(); } catch (e) { overlay.style.display = 'none'; }
    // begin loading the image — existing img.onload/img.onerror will handle the rest
    // start reveal sequence as soon as possible
    revealing = true;
    revealStart = performance.now();
    revealDone = false;
    img.src = imgSrc;
  }

  // staged reveal state
  let revealing = false;
  let revealStart = 0;
  let revealDuration = 1200; // ms for items to drop into place
  let revealDone = false;


  class Particle {
    // if absolute=true, x,y are canvas coordinates; otherwise they are image-local coords
    constructor(x, y, color, absolute = false) {
        if (absolute) {
          this.x = x;
          this.y = y;
        } else {
          const imgW = img.width * imgScale;
          const imgH = img.height * imgScale;
          this.x = x * imgScale + canvas.width/2 - imgW/2;
          this.y = y * imgScale + canvas.height/2 - imgH/2;
        }
        // store whether this particle is anchored to image-local coords
        this.imgX = absolute ? null : x;
        this.imgY = absolute ? null : y;
        // for absolute-positioned particles, store offset from canvas center so we can reposition on resize
        this.offsetX = this.x - canvas.width/2;
        this.offsetY = this.y - canvas.height/2;
      this.size = 1 + Math.random() * 2;
      this.baseX = this.x;
      this.baseY = this.y;
      this.color = color;
      this.angle = Math.random() * Math.PI * 2;
      this.radius = Math.random() * 2 + 1;
      this.speed = 0.02 + Math.random() * 0.02;
    }
    update() {
      this.angle += this.speed;
      this.x = this.baseX + Math.cos(this.angle) * this.radius * 5;
      this.y = this.baseY + Math.sin(this.angle) * this.radius * 5;
    }
    draw() {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.closePath();
      ctx.fill();
    }
  }

  img.onload = () => {
    console.log('Image loaded:', img.src, 'size', img.width, img.height);
    const temp = document.createElement("canvas");
    const tctx = temp.getContext("2d");
    temp.width = img.width;
    temp.height = img.height;
    tctx.drawImage(img, 0, 0);
    let data;
    try {
      data = tctx.getImageData(0, 0, img.width, img.height).data;
    } catch (err) {
      console.error('getImageData failed (CORS or tainted canvas?)', err);
      // fallback: create a simple alpha mask with a filled rect so particles still generate
      const fake = tctx.createImageData(img.width, img.height);
      for (let i = 0; i < fake.data.length; i += 4) {
        fake.data[i] = 255; // r
        fake.data[i+1] = 0; // g
        fake.data[i+2] = 128; // b
        fake.data[i+3] = 0; // fully transparent by default
      }
      // draw a central opaque ellipse as fallback
      tctx.clearRect(0,0,img.width,img.height);
      tctx.fillStyle = 'rgba(255,0,128,1)';
      tctx.beginPath();
      tctx.ellipse(img.width/2, img.height/2, img.width/3, img.height/3, 0, 0, Math.PI*2);
      tctx.fill();
      try {
        const fallback = tctx.getImageData(0,0,img.width,img.height).data;
        data = fallback;
      } catch (err2) {
        console.error('Fallback getImageData also failed', err2);
        // as an ultimate fallback, create a tiny 1x1 opaque pixel repeated
        data = new Uint8ClampedArray(img.width * img.height * 4);
        for (let i = 0; i < data.length; i += 4) {
          data[i] = 255; data[i+1] = 0; data[i+2] = 128; data[i+3] = 255;
        }
      }
    }

    // sample image with larger step to reduce particle count
    for (let y = 0; y < img.height; y += 8) {
      for (let x = 0; x < img.width; x += 8) {
        const index = (y * img.width + x) * 4;
        const alpha = data[index + 3];
        if (alpha > 128) {
          // force particle color to blue and use fewer particles
          // keep ~60% of detected points to reduce density
          if (Math.random() < 0.6) particles.push(new Particle(x, y, '#34b1eb'));
        }
      }
    }
  // --- build heart border points ---
    const borderPoints = [];
    const step = 2; // finer sampling for border detection
    function isOpaque(px, py) {
      if (px < 0 || py < 0 || px >= img.width || py >= img.height) return false;
      const i = (py * img.width + px) * 4 + 3;
      return data[i] > 128;
    }

    for (let y = 0; y < img.height; y += step) {
      for (let x = 0; x < img.width; x += step) {
        const i = (y * img.width + x) * 4 + 3;
        if (data[i] > 128) {
          // check 4-neighbors for transparency -> border
          if (!isOpaque(x - step, y) || !isOpaque(x + step, y) || !isOpaque(x, y - step) || !isOpaque(x, y + step)) {
            borderPoints.push({x, y});
          }
        }
      }
    }

    // sample border points to avoid too many hearts
    const sampled = [];
    const sampleCount = Math.min(120, borderPoints.length);
    if (borderPoints.length > 0) {
      const interval = Math.max(1, Math.floor(borderPoints.length / sampleCount));
      for (let i = 0; i < borderPoints.length; i += interval) {
        sampled.push(borderPoints[i]);
      }
    }

    // Heart class
    class Heart {
      // if absolute=true, x,y are canvas coords
      constructor(x, y, color, absolute = false) {
        if (absolute) {
          this.x = x;
          this.y = y;
        } else {
          const imgW = img.width * imgScale;
          const imgH = img.height * imgScale;
          this.x = x * imgScale + canvas.width/2 - imgW/2;
          this.y = y * imgScale + canvas.height/2 - imgH/2;
        }
        // keep image-local coordinates if available for reliable repositioning on resize
        this.imgX = absolute ? null : x;
        this.imgY = absolute ? null : y;
        this.offsetX = this.x - canvas.width/2;
        this.offsetY = this.y - canvas.height/2;
        this.baseX = this.x;
        this.baseY = this.y;
        this.size = 6 + Math.random() * 8;
        this.color = color || 'pink';
        this.phase = Math.random() * Math.PI * 2;
        this.speed = 0.02 + Math.random() * 0.03;
        this.opacity = 0.9;
        this.offset = Math.random() * 6 - 3;
      }
      update() {
        this.phase += this.speed;
        // pulse size and small outward movement
        const pulse = 0.15 + Math.sin(this.phase) * 0.15;
        const r = 1 + pulse;
        this.currentSize = this.size * r;
        // slight radial motion
        this.x = this.baseX + Math.cos(this.phase * 0.7) * (this.offset * 0.3);
        this.y = this.baseY + Math.sin(this.phase * 0.9) * (this.offset * 0.3);
        // blink opacity
        this.opacity = 0.5 + (Math.sin(this.phase * 1.2) + 1) / 4;
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.currentSize / 20, this.currentSize / 20);
        ctx.globalAlpha = this.opacity;
        // draw simple heart path
        ctx.beginPath();
        ctx.moveTo(0, -8);
        ctx.bezierCurveTo(-8, -18, -22, -6, 0, 10);
        ctx.bezierCurveTo(22, -6, 8, -18, 0, -8);
        ctx.closePath();
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.restore();
      }
    }

    const hearts = [];
    for (let i = 0; i < sampled.length; i++) {
      const p = sampled[i];
      // pick a brightish color based on the particle color nearby or fixed pink
      const idx = (p.y * img.width + p.x) * 4;
      const r = data[idx] || 255;
      const g = data[idx + 1] || 100;
      const b = data[idx + 2] || 150;
      const color = `rgba(${r},${g},${b},1)`;
      // override heart color to requested blue
      hearts.push(new Heart(p.x, p.y, '#34b1eb'));
    }

  // fallback visuals: if no particles or hearts were created, make visible replacements
    if (particles.length === 0) {
      for (let i = 0; i < 90; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = 60 + Math.random() * Math.min(canvas.width, canvas.height) / 3;
        const px = canvas.width/2 + Math.cos(angle) * r;
        const py = canvas.height/2 + Math.sin(angle) * r;
        particles.push(new Particle(px, py, '#34b1eb', true));
      }
    }

    if (hearts.length === 0) {
      // place some hearts on a circle around center for visibility
      const count = 24;
      for (let i = 0; i < count; i++) {
        const a = (i / count) * Math.PI * 2;
        const r = Math.min(canvas.width, canvas.height) * 0.25;
        const hx = canvas.width/2 + Math.cos(a) * r;
        const hy = canvas.height/2 + Math.sin(a) * r;
          // force fallback hearts to the requested blue color
          hearts.push(new Heart(hx, hy, '#34b1eb', true));
      }
    }

    // expose for resize handling
    window._stitch = {hearts, particles, img, data};

    // prepare staged reveal initial positions (start above canvas) and compute per-item delays
    const allItems = particles.concat(hearts);
    const canvasH = canvas.height;
    for (let item of allItems) {
      // target base positions already set (baseX/baseY)
      item.targetX = item.baseX;
      item.targetY = item.baseY;
      // start Y well above the top; keep random small X offset
      item.startX = item.targetX + (Math.random() - 0.5) * 20;
      item.startY = -50 - Math.random() * 120;
      // compute delay so items with smaller targetY appear earlier (top-to-bottom)
      const frac = (item.targetY + 0) / (canvasH || 1);
      item.revealDelay = Math.max(0, frac) * 700 + Math.random() * 120; // up to ~700ms stagger
      // reveal progress state
      item.revealed = false;
      // seed current positions to start positions for immediate animation
      item.baseX = item.startX;
      item.baseY = item.startY;
    }

    // draw the source image once at low opacity in the center to verify load (debug)
    try {
      ctx.save();
  ctx.globalAlpha = 0.25;
  const imgW = img.width * imgScale;
  const imgH = img.height * imgScale;
  const dx = canvas.width/2 - imgW/2;
  const dy = canvas.height/2 - imgH/2;
  ctx.drawImage(img, dx, dy, imgW, imgH);
      ctx.restore();
    } catch (e) {
      console.warn('Could not draw debug image onto main canvas:', e);
    }

    // if already started (user pressed Play before image loaded), begin reveal
    if (started) {
      revealing = true;
      revealStart = performance.now();
    }
    animate();
  };

  img.onerror = (e) => {
    console.error('Image failed to load:', img.src, e);
    // still start animate so user sees something
    // create simple fallback particles centered on canvas
    for (let i = 0; i < 90; i++) {
      const x = (Math.random() - 0.5) * 300 + canvas.width/2;
      const y = (Math.random() - 0.5) * 300 + canvas.height/2;
      particles.push(new Particle(x, y, '#34b1eb', true));
    }
    animate();
  };

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // if revealing, advance reveal animation for particles/hearts
    if (revealing && !revealDone) {
      const now = performance.now();
      let allDone = true;
      for (let p of particles) {
        const t = Math.max(0, now - revealStart - (p.revealDelay || 0));
        const prog = Math.min(1, t / revealDuration);
        // easeOutCubic
        const e = 1 - Math.pow(1 - prog, 3);
        p.baseX = p.startX + (p.targetX - p.startX) * e;
        p.baseY = p.startY + (p.targetY - p.startY) * e;
        if (prog < 1) allDone = false;
      }
      for (let h of (window._stitch && window._stitch.hearts) || []) {
        const t = Math.max(0, now - revealStart - (h.revealDelay || 0));
        const prog = Math.min(1, t / revealDuration);
        const e = 1 - Math.pow(1 - prog, 3);
        h.baseX = h.startX + (h.targetX - h.startX) * e;
        h.baseY = h.startY + (h.targetY - h.startY) * e;
        if (prog < 1) allDone = false;
      }
      if (allDone) {
        revealDone = true;
        revealing = false;
        // small pause then enable swimmers/caption fully
        setTimeout(() => { /* nothing for now; caption draws when image ready */ }, 120);
      }
    }

    // draw particles
    for (let p of particles) {
      p.update();
      p.draw();
    }

    // draw hearts if present
    if (window._stitch && window._stitch.hearts) {
      for (let h of window._stitch.hearts) {
        h.update();
        h.draw();
      }
    }

    // debug overlay: if nothing drawn, show helpful message and small preview of image
    const hasParticles = particles && particles.length > 0;
    const hasHearts = window._stitch && window._stitch.hearts && window._stitch.hearts.length > 0;
    if (!hasParticles && !hasHearts) {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '18px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Không có hạt hoặc trái tim — kiểm tra Console (F12) để xem lỗi tải ảnh', canvas.width/2, canvas.height/2 - 20);
      // draw small preview of image if available
      if (window._stitch && window._stitch.img && window._stitch.img.complete) {
        try {
          const previewW = Math.min(200, window._stitch.img.width);
          const previewH = (previewW / window._stitch.img.width) * window._stitch.img.height;
          ctx.globalAlpha = 0.9;
          ctx.drawImage(window._stitch.img, canvas.width/2 - previewW/2, canvas.height/2, previewW, previewH);
        } catch (e) {
          // ignore draw errors
        }
      }
      ctx.restore();
    }
  // draw caption under the scaled image (only fully visible after revealDone)
    try {
        if (window._stitch && window._stitch.img && window._stitch.img.complete) {
          const imgW = window._stitch.img.width * imgScale;
          const imgH = window._stitch.img.height * imgScale;
          const cx = canvas.width/2;
          const top = canvas.height/2 - imgH/2;
          const captionY = top + imgH + 30; // 30px below image
          // base caption (pink)
    ctx.save();
    // fade caption until reveal completes
    ctx.globalAlpha = revealDone ? 1.0 : 0.0;
    // glowing bold caption
    ctx.fillStyle = '#ff5fb0'; // pink
    ctx.font = '700 35px "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(255,95,176,0.9)';
    ctx.shadowBlur = 12;
    ctx.fillText('♡awdrug♡', cx, captionY);
    // slight bright outline to emphasize bold glow
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.strokeText('♡awdrug♡', cx, captionY);
    ctx.restore();

          // swimmers: only create and draw when explicitly activated by clicking the image
          if (window._stitch && window._stitch.swimmersVisible && !window._stitch.swimmers) {
            const glyphs = ['𓆝 ','𓆟 ','𓆞 ','𓆝 ','𓆟 '];
            const swimmers = [];
            const textWidth = ctx.measureText('♡awdrug♡').width;
            const startX = cx - textWidth/2 - 40;
            const endX = cx + textWidth/2 + 40;
            for (let i = 0; i < glyphs.length; i++) {
              swimmers.push({
                ch: glyphs[i],
                x: startX + (i / glyphs.length) * (endX - startX),
                y: captionY,
                // much slower swim speed (right-to-left -> negative)
                speed: -(0.06 + Math.random() * 0.12),
                // fish-like wave params
                phase: Math.random() * Math.PI * 2,
                amp: 6 + Math.random() * 6,
                freq: 0.02 + Math.random() * 0.02
              });
            }
            window._stitch.swimmers = {arr: swimmers, startX, endX};
          }

          // animate swimmers opacity toward target
          const sdata = (window._stitch && window._stitch.swimmers) ? window._stitch.swimmers : null;
          ctx.save();
          // smooth fade: move opacity ~10% of remaining difference per frame
          if (window._stitch) {
            const cur = window._stitch.swimmersOpacity || 0;
            const target = (typeof window._stitch.swimmersFadeTarget === 'number') ? window._stitch.swimmersFadeTarget : (window._stitch.swimmersVisible ? 1 : 0);
            const next = cur + (target - cur) * 0.12;
            window._stitch.swimmersOpacity = Math.max(0, Math.min(1, next));
            // if fully faded out and target is 0, mark not visible but keep swimmers array so resume continues positions
            if (window._stitch.swimmersOpacity <= 0.001 && target === 0) {
              window._stitch.swimmersVisible = false;
            }
            ctx.globalAlpha = window._stitch.swimmersOpacity || 0;
          } else {
            ctx.globalAlpha = 0;
          }
          ctx.fillStyle = '#34b1eb';
          ctx.font = '35px "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          // per-fish fade parameters
          const fadeWidth = (sdata && sdata.fadeWidth) ? sdata.fadeWidth : 60; // px
          if (sdata) for (let s of sdata.arr) {
            // update wave phase
            s.phase += s.freq;
            const yOffset = Math.sin(s.phase) * s.amp;
            // small rotation based on derivative of sine (approx)
            const rot = Math.cos(s.phase) * 0.12;

            // compute per-fish alpha: fade-out near left edge and fade-in per appearDelay
            const globalOpacity = (window._stitch && typeof window._stitch.swimmersOpacity === 'number') ? window._stitch.swimmersOpacity : 1;
            let fadeOutAlpha = 1;
            try {
              const dist = s.x - sdata.startX; // distance from left edge
              if (dist < fadeWidth) fadeOutAlpha = Math.max(0, dist / fadeWidth);
            } catch (e) { fadeOutAlpha = 1; }
            let fadeInAlpha = 1;
            try {
              const startTs = (window._stitch && window._stitch.swimmersStart) || 0;
              const elapsed = Math.max(0, performance.now() - startTs);
              const localT = Math.max(0, elapsed - (s.appearDelay || 0));
              const inDur = 350; // ms fade-in per fish
              fadeInAlpha = Math.min(1, localT / inDur);
            } catch (e) { fadeInAlpha = 1; }
            const localAlpha = fadeOutAlpha * fadeInAlpha;

            ctx.save();
            // combine global swimmers opacity with per-fish local alpha
            ctx.globalAlpha = globalOpacity * localAlpha;
            ctx.translate(s.x, s.y + yOffset);
            ctx.rotate(rot);
            ctx.fillText(s.ch, 0, 0);
            ctx.restore();

            s.x += s.speed;
            // wrap from left to right (since moving left)
            if (s.x < sdata.startX) s.x = sdata.endX;
          }
          ctx.restore();
        }
    } catch (e) {
      // ignore caption draw errors
    }

    requestAnimationFrame(animate);
  }

  // robust resize handling (debounced) using visualViewport when available to support iOS Safari
  let resizeTimer = null;
  function getViewportSize() {
    if (window.visualViewport) {
      return {w: Math.floor(window.visualViewport.width), h: Math.floor(window.visualViewport.height)};
    }
    return {w: window.innerWidth, h: window.innerHeight};
  }

  function doResize() {
    const vp = getViewportSize();
    // update canvases
    canvas.width = vp.w;
    canvas.height = vp.h;
    overlayCanvas.width = vp.w;
    overlayCanvas.height = vp.h;
    // recompute columns for overlay matrix
    cols = Math.floor(overlayCanvas.width / 16) + 1;
    drops.length = cols;
    for (let i = 0; i < cols; i++) drops[i] = Math.floor(Math.random() * overlayCanvas.height / 16);

    // reposition hearts and particles relative to new center using stored img-local coords or offsets
    if (window._stitch && window._stitch.hearts && window._stitch.img) {
      const {hearts, img} = window._stitch;
      const imgW = img.width * imgScale;
      const imgH = img.height * imgScale;
      const cx = canvas.width/2;
      const cy = canvas.height/2;
      for (let h of hearts) {
        if (h.imgX != null && h.imgY != null) {
          h.baseX = h.imgX * imgScale + cx - imgW/2;
          h.baseY = h.imgY * imgScale + cy - imgH/2;
        } else {
          // keep offset from center
          h.baseX = cx + (h.offsetX || (h.baseX - (cx))) ;
          h.baseY = cy + (h.offsetY || (h.baseY - (cy))) ;
        }
      }
      // particles
      for (let p of particles) {
        if (p.imgX != null && p.imgY != null) {
          p.baseX = p.imgX * imgScale + cx - imgW/2;
          p.baseY = p.imgY * imgScale + cy - imgH/2;
        } else {
          p.baseX = cx + (p.offsetX || (p.baseX - (cx)));
          p.baseY = cy + (p.offsetY || (p.baseY - (cy)));
        }
      }
      // swimmers: recompute caption positions so they remain under image
      if (window._stitch.swimmers && window._stitch.img) {
        const captionY = cy - imgH/2 + imgH + 30;
        const sdata = window._stitch.swimmers;
        // recompute text bounds by measuring with ctx using the current canvas size
        ctx.save();
        ctx.font = '700 22px "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
        const textWidth = ctx.measureText('♡awdrug♡').width;
        ctx.restore();
        const startX = cx - textWidth/2 - 40;
        const endX = cx + textWidth/2 + 40;
        sdata.startX = startX;
        sdata.endX = endX;
        // shift swimmers vertically to captionY
        for (let i = 0; i < sdata.arr.length; i++) {
          const s = sdata.arr[i];
          // keep relative fraction along the span
          const frac = (s.x - (sdata.startX)) / (sdata.endX - sdata.startX);
          s.x = startX + (frac || (i / sdata.arr.length)) * (endX - startX);
          s.y = captionY;
        }
      }
    }
  }

  function scheduleResize() {
    if (resizeTimer) clearTimeout(resizeTimer);
    resizeTimer = setTimeout(doResize, 80);
  }

  // use visualViewport events if available (better on mobile Safari)
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', scheduleResize);
    window.visualViewport.addEventListener('scroll', scheduleResize);
  }
  window.addEventListener('resize', scheduleResize);
  // run once to ensure correct sizing on load
  scheduleResize();
  
  // --- click-to-trigger: start music + show swimmers when user clicks the stitch image ---
  // Swapped the generated WebAudio melody for a simple HTMLAudioElement-based player
  // so you can supply an MP3 file. Use window.setMusicFile(url) to point to your file.

  let audioElem = null;
  let musicFileUrl = 'obito.mp3'; // set via window.setMusicFile(url)
  let isMusicPlaying = false;
  const audioVolume = 0.12; // low volume
  // swimmers fade state (0..1)
  if (!window._stitch) window._stitch = {};
  window._stitch.swimmersOpacity = window._stitch.swimmersOpacity || 0.0;
  window._stitch.swimmersFadeTarget = window._stitch.swimmersFadeTarget || 0.0;

  // initialize HTMLAudioElement player (created lazily after user gesture)
  function initAudio() {
    if (audioElem) return;
    audioElem = new Audio();
    audioElem.crossOrigin = 'anonymous';
    audioElem.loop = true;
    audioElem.volume = audioVolume;
    if (musicFileUrl) audioElem.src = musicFileUrl;
    audioElem.addEventListener('ended', () => { isMusicPlaying = false; });
  }

  // let page scripts set/change the music file URL at runtime
  window.setMusicFile = function(url) {
    musicFileUrl = url || null;
    if (audioElem) {
      try {
        audioElem.pause();
      } catch (e) {}
      audioElem.src = musicFileUrl || '';
      audioElem.load();
      audioElem.volume = audioVolume;
    }
  };

  function startMusic() {
    initAudio();
    // must be called from a user gesture (click) — triggerMusicAndSwimmers ensures that
    if (!audioElem) return;
    audioElem.play().then(() => { isMusicPlaying = true; }).catch(e => {
      console.warn('audio play failed', e);
    });
  }

  function stopMusic() {
    // stopMusic(reset = true): if reset=false, only pause and keep currentTime so play() will resume
    function _stop(reset) {
      if (audioElem) { try { audioElem.pause(); if (reset) audioElem.currentTime = 0; } catch (e) {} }
      isMusicPlaying = false;
    }
    // backward-compatible single-arg call
    _stop(true);
  }

  // public variant that accepts reset flag
  function stopMusicReset(reset = true) {
    if (audioElem) { try { audioElem.pause(); if (reset) audioElem.currentTime = 0; } catch (e) {} }
    isMusicPlaying = false;
  }

  function ensureSwimmersExist() {
    if (!window._stitch) window._stitch = {};
    if (window._stitch.swimmers) return;
    // create swimmers under the caption (same logic as caption init)
    try {
      const glyphs = ['𓆝','𓆟','𓆞','𓆝','𓆟'];
      const swimmers = [];
      ctx.save();
      ctx.font = '700 22px "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
      const textWidth = ctx.measureText('♡awdrug♡').width;
      ctx.restore();
      const cx = canvas.width/2;
      const startX = cx - textWidth/2 - 40;
      const endX = cx + textWidth/2 + 40;
      const captionY = canvas.height/2 - (img.height * imgScale)/2 + (img.height * imgScale) + 30;
      for (let i = 0; i < glyphs.length; i++) {
        swimmers.push({
          ch: glyphs[i],
          x: startX + (i / glyphs.length) * (endX - startX),
          y: captionY,
          speed: -(0.06 + Math.random() * 0.12),
          phase: Math.random() * Math.PI * 2,
          amp: 6 + Math.random() * 6,
          freq: 0.02 + Math.random() * 0.02
        });
      }
      // add per-fish appearDelay (staggered fade-in) and default fadeWidth
      const appearBase = 120; // ms between fish
      for (let i = 0; i < swimmers.length; i++) swimmers[i].appearDelay = i * appearBase;
      window._stitch.swimmers = {arr: swimmers, startX, endX, fadeWidth: 60};
    } catch (e) {
      // ignore
    }
  }

  // runtime helper to adjust per-fish fade width
  window.setSwimmerFadeWidth = function(px) {
    try {
      if (!window._stitch) window._stitch = {};
      if (!window._stitch.swimmers) ensureSwimmersExist();
      if (window._stitch.swimmers) window._stitch.swimmers.fadeWidth = Number(px) || 60;
      return window._stitch.swimmers.fadeWidth;
    } catch (e) { return null; }
  };

  function triggerMusicAndSwimmers() {
    try {
      // toggle: first click starts music + fades swimmers in; second click pauses music + fades swimmers out
      if (!window._stitch) window._stitch = {};
      const currentlyVisible = !!window._stitch.swimmersVisible;
      if (!currentlyVisible) {
        // show: if audio is paused (has currentTime > 0) resume, otherwise start
        if (audioElem && audioElem.paused && audioElem.currentTime > 0) {
          audioElem.play().then(() => { isMusicPlaying = true; }).catch(e => console.warn('resume failed', e));
        } else if (!isMusicPlaying) {
          startMusic();
        }
        window._stitch.swimmersVisible = true;
        window._stitch.swimmersFadeTarget = 1.0;
        // ensure swimmers array exists when we begin fading in
        if (!window._stitch.swimmers) ensureSwimmersExist();
  // record start time for per-fish fade-in
  window._stitch.swimmersStart = performance.now();
      } else {
        // hide: begin fade-out, pause music without resetting position so it can resume
        window._stitch.swimmersFadeTarget = 0.0;
        try { stopMusicReset(false); } catch (e) {}
      }
    } catch (e) {
      console.warn('trigger failed', e);
    }
  }

  // detect clicks on the stitch image area
  canvas.addEventListener('click', (ev) => {
    try {
      if (!img || !img.complete) return;
      const rect = canvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const imgW = img.width * imgScale;
      const imgH = img.height * imgScale;
      const dx = canvas.width/2 - imgW/2;
      const dy = canvas.height/2 - imgH/2;
      if (x >= dx && x <= dx + imgW && y >= dy && y <= dy + imgH) {
        triggerMusicAndSwimmers();
      }
    } catch (e) {}
  });
  </script>
</body>
</html>




