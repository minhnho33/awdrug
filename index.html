<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>‚ô°awdrug‚ô°</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: black;
      overflow: hidden;
    }
    canvas {
      position: absolute;
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
  <!-- Local font faces: place font files in `fonts/` (e.g. NotoSansMono-Regular.woff2, NotoSans-Regular.woff2) -->
  <style>
    @font-face {
      font-family: 'Noto Sans Mono Local';
      src: url('fonts/NotoSansMono-Regular.woff2') format('woff2');
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // scale factor for drawing the image (30% of original)
  const imgScale = 0.5;

  let particles = [];
  const img = new Image();
  // do not load image until user clicks Play; startScene() will set src
  const imgSrc = "stitch.png"; // image path
  img.crossOrigin = "anonymous";
  let started = false;

  // create a fullscreen overlay with a Play button; nothing runs until clicked
  const overlay = document.createElement('div');
  overlay.style.position = 'fixed';
  overlay.style.top = '0';
  overlay.style.left = '0';
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.background = 'rgba(0,0,0,0.85)';
  overlay.style.zIndex = '10000';

  // overlay canvas for 'running code' effect
  const overlayCanvas = document.createElement('canvas');
  overlayCanvas.style.position = 'absolute';
  overlayCanvas.style.top = '0';
  overlayCanvas.style.left = '0';
  overlayCanvas.style.width = '100%';
  overlayCanvas.style.height = '100%';
  overlayCanvas.width = window.innerWidth;
  overlayCanvas.height = window.innerHeight;
  overlay.appendChild(overlayCanvas);

  const ovCtx = overlayCanvas.getContext('2d');
  let cols = Math.floor(overlayCanvas.width / 16) + 1;
  const drops = new Array(cols).fill(1);
  const chars = '01{}[]()<>,.:;+-=*/\u2588‚ñà‚ñì‚ñí‚ñëabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let overlayAnimId = null;

  // --- Play button configuration (user-editable) ---
  // You can modify this object in the console or via window.setPlayBtnConfig({...})
  const playBtnConfig = {
    // positionMode: 'inline' (aligned under terminal) | 'free' (absolute in overlay)
    positionMode: 'free',
    // when inline: align: 'left' | 'center' | 'right'
    align: 'left',
    // additional horizontal offset in px applied as left padding inside the button wrapper (inline mode)
    offsetX: '30px',
    // additional vertical offset in px applied to the button (margin-top in inline mode)
    offsetY: 0,
    // wrapper width for terminal/button area (accepts CSS length like '70%' or '600px')
    wrapperWidth: '70%',
    // when free: CSS left/top values (can be '50%', '120px', etc.)
    freeX: '21%',
    freeY: '62%',
    // when free and anchorCenter=true the button will be centered at (freeX,freeY) using transform
    anchorCenter: true
  };

  function applyPlayBtnConfig() {
    try {
      // always apply wrapper width when termWrap exists
      if (typeof termWrap !== 'undefined' && termWrap) termWrap.style.width = playBtnConfig.wrapperWidth;

      // handle free (absolute) positioning vs inline (inside terminal area)
      if (typeof playBtn !== 'undefined' && playBtn) {
        if (playBtnConfig.positionMode === 'free') {
          // ensure playBtn is absolutely positioned inside the overlay
          playBtn.style.position = 'absolute';
          playBtn.style.left = (typeof playBtnConfig.freeX === 'number') ? (playBtnConfig.freeX + 'px') : (playBtnConfig.freeX || '50%');
          playBtn.style.top = (typeof playBtnConfig.freeY === 'number') ? (playBtnConfig.freeY + 'px') : (playBtnConfig.freeY || '50%');
          playBtn.style.marginTop = '0';
          playBtn.style.transform = playBtnConfig.anchorCenter ? 'translate(-50%, -50%)' : 'none';
          // move into overlay container so it's free to position
          if (typeof overlay !== 'undefined' && overlay && playBtn.parentElement !== overlay) {
            try { playBtn.parentElement && playBtn.parentElement.removeChild(playBtn); } catch (e) {}
            overlay.appendChild(playBtn);
          }
          // hide the inline wrapper if present
          if (typeof btnWrap !== 'undefined' && btnWrap) btnWrap.style.display = 'none';
        } else {
          // inline mode: place button back into btnWrap and use flex alignment
          playBtn.style.position = 'relative';
          playBtn.style.transform = 'none';
          playBtn.style.marginTop = (playBtnConfig.offsetY || 0) + 'px';
          if (typeof btnWrap !== 'undefined' && btnWrap) {
            btnWrap.style.display = 'flex';
            btnWrap.style.justifyContent = playBtnConfig.align === 'left' ? 'flex-start' : (playBtnConfig.align === 'right' ? 'flex-end' : 'center');
            btnWrap.style.padding = `8px 0 24px ${playBtnConfig.offsetX || 0}px`;
            if (playBtn.parentElement !== btnWrap) {
              try { playBtn.parentElement && playBtn.parentElement.removeChild(playBtn); } catch (e) {}
              btnWrap.appendChild(playBtn);
            }
          }
        }
      }
    } catch (e) {
      // ignore before elements exist
    }
  }

  // expose a helper to change config at runtime
  window.setPlayBtnConfig = function(cfg) {
    Object.assign(playBtnConfig, cfg || {});
    applyPlayBtnConfig();
    return playBtnConfig;
  };

  function overlayResize() {
    overlayCanvas.width = window.innerWidth;
    overlayCanvas.height = window.innerHeight;
    cols = Math.floor(overlayCanvas.width / 16) + 1;
    drops.length = cols;
    for (let i = 0; i < cols; i++) drops[i] = Math.floor(Math.random() * overlayCanvas.height / 16);
  }

  window.addEventListener('resize', overlayResize);

  function overlayFrame() {
    // fade the canvas a bit
    ovCtx.fillStyle = 'rgba(0,0,0,0.15)';
    ovCtx.fillRect(0, 0, overlayCanvas.width, overlayCanvas.height);

  ovCtx.fillStyle = '#34b1eb'; // blue hacker color
  ovCtx.font = '14px "Noto Sans Mono Local", "Noto Sans Local", monospace';
    for (let i = 0; i < drops.length; i++) {
      const text = chars.charAt(Math.floor(Math.random() * chars.length));
      const x = i * 16;
      const y = drops[i] * 16;
      ovCtx.fillText(text, x, y);
      if (y > overlayCanvas.height && Math.random() > 0.975) {
        drops[i] = 0;
      }
      drops[i]++;
    }
    overlayAnimId = requestAnimationFrame(overlayFrame);
  }

  const playBtn = document.createElement('button');
  playBtn.textContent = '0909';
  playBtn.setAttribute('aria-label','Play');
  playBtn.style.fontSize = '35px';
  playBtn.style.padding = '8px 12px';
  playBtn.style.borderRadius = '100px';
  playBtn.style.border = 'none';
  playBtn.style.cursor = 'pointer';
  playBtn.style.background = '#ff8fce';
  playBtn.style.color = '#fff';
  // inline positioning; will be placed inside termWrap under the terminal text
  playBtn.style.position = 'relative';
  playBtn.style.zIndex = '10002';
  playBtn.style.display = 'none'; // hidden until terminal finishes
  playBtn.onclick = startScene;
  document.body.appendChild(overlay);

  // responsive tweak: slightly smaller button on very small viewports
  function adjustBtnForViewport() {
    const w = (window.visualViewport && window.visualViewport.width) || window.innerWidth;
    if (w < 420) {
      playBtn.style.fontSize = '35px';
      playBtn.style.padding = '6px 10px';
    } else {
      playBtn.style.fontSize = '35px';
      playBtn.style.padding = '8px 12px';
    }
  }
  adjustBtnForViewport();
  window.addEventListener('resize', adjustBtnForViewport);

  // terminal-like text box on overlay
  const term = document.createElement('pre');
  term.style.position = 'relative';
  term.style.zIndex = '10001';
  term.style.width = '100%';
  term.style.maxWidth = '1920px';
  term.style.margin = '0 auto 12px';
  term.style.padding = '18px';
  term.style.background = 'rgba(0,0,0,0.6)';
  term.style.color = '#34b1eb';
  term.style.font = '30px "Noto Sans Mono Local", "Noto Sans Local", "Segoe UI Mono", "Noto Sans Mono", monospace';
  term.style.borderRadius = '6px';
  term.style.overflow = 'hidden';
  term.style.minHeight = '120px';
  term.style.maxHeight = '40vh';
  term.style.overflowY = 'auto';
  term.textContent = '';
  // insert terminal and place the button under it, left-aligned with the text
  const termWrap = document.createElement('div');
  termWrap.style.display = 'flex';
  termWrap.style.flexDirection = 'column';
  termWrap.style.alignItems = 'flex-start'; // left-align children
  termWrap.style.width = '100%';
  termWrap.style.maxWidth = '1920px';
  termWrap.style.margin = '0 auto';
  termWrap.appendChild(term);
  // small container for the button, left-aligned with the terminal text
  const btnWrap = document.createElement('div');
  btnWrap.style.width = '100%';
  btnWrap.style.display = 'flex';
  btnWrap.style.justifyContent = 'center';
  btnWrap.style.padding = '8px 0 24px 0';
  btnWrap.appendChild(playBtn);
  termWrap.appendChild(btnWrap);
  overlay.appendChild(termWrap);
  // apply any initial play button configuration
  applyPlayBtnConfig();

  // prepare fake command lines
  const terminalLines = [
    'Kh·ªüi ƒë·ªông awdrug.exe...',
    'ƒêang c√†i ƒë·∫∑t g√≥i d·ªÖ th∆∞∆°ng b·ªï sung...',
    'Buffer nƒÉng l∆∞·ª£ng t√≠ch c·ª±c (ƒë·ª´ng tua nha)...',
    'C√†i ƒë·∫∑t 0909.exe phi√™n b·∫£n v√¥ h·∫°n...',
    'Th√™m ch√∫t x√≠u d·ªÖ th∆∞∆°ng awdrug...',
    'S·∫Øp xong r·ªìi, ch·ªù x√≠...',
    'Ho√†n t·∫•t! Nh·∫•n n√∫t th√¥i ‚ù§Ô∏é...'
  ];

  // typing effect
  let tLine = 0;
  let tChar = 0;
  function typeNextChar() {
    if (tLine >= terminalLines.length) return finishTerminal();
    const line = terminalLines[tLine];
    term.textContent = terminalLines.slice(0, tLine).join('\n') + (tChar > 0 ? '\n' : '') + line.slice(0, tChar);
    tChar++;
    if (tChar > line.length) {
      // move to next line after a short pause
      tLine++;
      tChar = 0;
      setTimeout(typeNextChar, 400 + Math.random() * 300);
    } else {
      setTimeout(typeNextChar, 24 + Math.random() * 30);
    }
  }

  function finishTerminal() {
    // show play button when done
    playBtn.style.display = 'inline-block';
    // ensure it's centered and accessible
    playBtn.focus();
  }

  // start the overlay animation and terminal typing
  overlayFrame();
  setTimeout(typeNextChar, 400);

  function stopOverlay() {
    if (overlayAnimId) cancelAnimationFrame(overlayAnimId);
    try { window.removeEventListener('resize', overlayResize); } catch (e) {}
  }

  function startScene() {
    if (started) return;
    started = true;
    stopOverlay();
    try { overlay.remove(); } catch (e) { overlay.style.display = 'none'; }
    // begin loading the image ‚Äî existing img.onload/img.onerror will handle the rest
    // start reveal sequence as soon as possible
    revealing = true;
    revealStart = performance.now();
    revealDone = false;
    img.src = imgSrc;
  }

  // staged reveal state
  let revealing = false;
  let revealStart = 0;
  let revealDuration = 1200; // ms for items to drop into place
  let revealDone = false;


  class Particle {
    // if absolute=true, x,y are canvas coordinates; otherwise they are image-local coords
    constructor(x, y, color, absolute = false) {
        if (absolute) {
          this.x = x;
          this.y = y;
        } else {
          const imgW = img.width * imgScale;
          const imgH = img.height * imgScale;
          this.x = x * imgScale + canvas.width/2 - imgW/2;
          this.y = y * imgScale + canvas.height/2 - imgH/2;
        }
        // store whether this particle is anchored to image-local coords
        this.imgX = absolute ? null : x;
        this.imgY = absolute ? null : y;
        // for absolute-positioned particles, store offset from canvas center so we can reposition on resize
        this.offsetX = this.x - canvas.width/2;
        this.offsetY = this.y - canvas.height/2;
      this.size = 1 + Math.random() * 2;
      this.baseX = this.x;
      this.baseY = this.y;
      this.color = color;
      this.angle = Math.random() * Math.PI * 2;
      this.radius = Math.random() * 2 + 1;
      this.speed = 0.02 + Math.random() * 0.02;
    }
    update() {
      this.angle += this.speed;
      this.x = this.baseX + Math.cos(this.angle) * this.radius * 5;
      this.y = this.baseY + Math.sin(this.angle) * this.radius * 5;
    }
    draw() {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.closePath();
      ctx.fill();
    }
  }

  img.onload = () => {
    console.log('Image loaded:', img.src, 'size', img.width, img.height);
    const temp = document.createElement("canvas");
    const tctx = temp.getContext("2d");
    temp.width = img.width;
    temp.height = img.height;
    tctx.drawImage(img, 0, 0);
    let data;
    try {
      data = tctx.getImageData(0, 0, img.width, img.height).data;
    } catch (err) {
      console.error('getImageData failed (CORS or tainted canvas?)', err);
      // fallback: create a simple alpha mask with a filled rect so particles still generate
      const fake = tctx.createImageData(img.width, img.height);
      for (let i = 0; i < fake.data.length; i += 4) {
        fake.data[i] = 255; // r
        fake.data[i+1] = 0; // g
        fake.data[i+2] = 128; // b
        fake.data[i+3] = 0; // fully transparent by default
      }
      // draw a central opaque ellipse as fallback
      tctx.clearRect(0,0,img.width,img.height);
      tctx.fillStyle = 'rgba(255,0,128,1)';
      tctx.beginPath();
      tctx.ellipse(img.width/2, img.height/2, img.width/3, img.height/3, 0, 0, Math.PI*2);
      tctx.fill();
      try {
        const fallback = tctx.getImageData(0,0,img.width,img.height).data;
        data = fallback;
      } catch (err2) {
        console.error('Fallback getImageData also failed', err2);
        // as an ultimate fallback, create a tiny 1x1 opaque pixel repeated
        data = new Uint8ClampedArray(img.width * img.height * 4);
        for (let i = 0; i < data.length; i += 4) {
          data[i] = 255; data[i+1] = 0; data[i+2] = 128; data[i+3] = 255;
        }
      }
    }

    // sample image with larger step to reduce particle count
    for (let y = 0; y < img.height; y += 8) {
      for (let x = 0; x < img.width; x += 8) {
        const index = (y * img.width + x) * 4;
        const alpha = data[index + 3];
        if (alpha > 128) {
          // force particle color to blue and use fewer particles
          // keep ~60% of detected points to reduce density
          if (Math.random() < 0.6) particles.push(new Particle(x, y, '#34b1eb'));
        }
      }
    }
  // --- build heart border points ---
    const borderPoints = [];
    const step = 2; // finer sampling for border detection
    function isOpaque(px, py) {
      if (px < 0 || py < 0 || px >= img.width || py >= img.height) return false;
      const i = (py * img.width + px) * 4 + 3;
      return data[i] > 128;
    }

    for (let y = 0; y < img.height; y += step) {
      for (let x = 0; x < img.width; x += step) {
        const i = (y * img.width + x) * 4 + 3;
        if (data[i] > 128) {
          // check 4-neighbors for transparency -> border
          if (!isOpaque(x - step, y) || !isOpaque(x + step, y) || !isOpaque(x, y - step) || !isOpaque(x, y + step)) {
            borderPoints.push({x, y});
          }
        }
      }
    }

    // sample border points to avoid too many hearts
    const sampled = [];
    const sampleCount = Math.min(120, borderPoints.length);
    if (borderPoints.length > 0) {
      const interval = Math.max(1, Math.floor(borderPoints.length / sampleCount));
      for (let i = 0; i < borderPoints.length; i += interval) {
        sampled.push(borderPoints[i]);
      }
    }

    // Heart class
    class Heart {
      // if absolute=true, x,y are canvas coords
      constructor(x, y, color, absolute = false) {
        if (absolute) {
          this.x = x;
          this.y = y;
        } else {
          const imgW = img.width * imgScale;
          const imgH = img.height * imgScale;
          this.x = x * imgScale + canvas.width/2 - imgW/2;
          this.y = y * imgScale + canvas.height/2 - imgH/2;
        }
        // keep image-local coordinates if available for reliable repositioning on resize
        this.imgX = absolute ? null : x;
        this.imgY = absolute ? null : y;
        this.offsetX = this.x - canvas.width/2;
        this.offsetY = this.y - canvas.height/2;
        this.baseX = this.x;
        this.baseY = this.y;
        this.size = 6 + Math.random() * 8;
        this.color = color || 'pink';
        this.phase = Math.random() * Math.PI * 2;
        this.speed = 0.02 + Math.random() * 0.03;
        this.opacity = 0.9;
        this.offset = Math.random() * 6 - 3;
      }
      update() {
        this.phase += this.speed;
        // pulse size and small outward movement
        const pulse = 0.15 + Math.sin(this.phase) * 0.15;
        const r = 1 + pulse;
        this.currentSize = this.size * r;
        // slight radial motion
        this.x = this.baseX + Math.cos(this.phase * 0.7) * (this.offset * 0.3);
        this.y = this.baseY + Math.sin(this.phase * 0.9) * (this.offset * 0.3);
        // blink opacity
        this.opacity = 0.5 + (Math.sin(this.phase * 1.2) + 1) / 4;
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.currentSize / 20, this.currentSize / 20);
        ctx.globalAlpha = this.opacity;
        // draw simple heart path
        ctx.beginPath();
        ctx.moveTo(0, -8);
        ctx.bezierCurveTo(-8, -18, -22, -6, 0, 10);
        ctx.bezierCurveTo(22, -6, 8, -18, 0, -8);
        ctx.closePath();
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.restore();
      }
    }

    const hearts = [];
    for (let i = 0; i < sampled.length; i++) {
      const p = sampled[i];
      // pick a brightish color based on the particle color nearby or fixed pink
      const idx = (p.y * img.width + p.x) * 4;
      const r = data[idx] || 255;
      const g = data[idx + 1] || 100;
      const b = data[idx + 2] || 150;
      const color = `rgba(${r},${g},${b},1)`;
      // override heart color to requested blue
      hearts.push(new Heart(p.x, p.y, '#34b1eb'));
    }

  // fallback visuals: if no particles or hearts were created, make visible replacements
    if (particles.length === 0) {
      for (let i = 0; i < 90; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = 60 + Math.random() * Math.min(canvas.width, canvas.height) / 3;
        const px = canvas.width/2 + Math.cos(angle) * r;
        const py = canvas.height/2 + Math.sin(angle) * r;
        particles.push(new Particle(px, py, '#34b1eb', true));
      }
    }

    if (hearts.length === 0) {
      // place some hearts on a circle around center for visibility
      const count = 24;
      for (let i = 0; i < count; i++) {
        const a = (i / count) * Math.PI * 2;
        const r = Math.min(canvas.width, canvas.height) * 0.25;
        const hx = canvas.width/2 + Math.cos(a) * r;
        const hy = canvas.height/2 + Math.sin(a) * r;
          // force fallback hearts to the requested blue color
          hearts.push(new Heart(hx, hy, '#34b1eb', true));
      }
    }

    // expose for resize handling
    window._stitch = {hearts, particles, img, data};

    // prepare staged reveal initial positions (start above canvas) and compute per-item delays
    const allItems = particles.concat(hearts);
    const canvasH = canvas.height;
    for (let item of allItems) {
      // target base positions already set (baseX/baseY)
      item.targetX = item.baseX;
      item.targetY = item.baseY;
      // start Y well above the top; keep random small X offset
      item.startX = item.targetX + (Math.random() - 0.5) * 20;
      item.startY = -50 - Math.random() * 120;
      // compute delay so items with smaller targetY appear earlier (top-to-bottom)
      const frac = (item.targetY + 0) / (canvasH || 1);
      item.revealDelay = Math.max(0, frac) * 700 + Math.random() * 120; // up to ~700ms stagger
      // reveal progress state
      item.revealed = false;
      // seed current positions to start positions for immediate animation
      item.baseX = item.startX;
      item.baseY = item.startY;
    }

    // draw the source image once at low opacity in the center to verify load (debug)
    try {
      ctx.save();
  ctx.globalAlpha = 0.25;
  const imgW = img.width * imgScale;
  const imgH = img.height * imgScale;
  const dx = canvas.width/2 - imgW/2;
  const dy = canvas.height/2 - imgH/2;
  ctx.drawImage(img, dx, dy, imgW, imgH);
      ctx.restore();
    } catch (e) {
      console.warn('Could not draw debug image onto main canvas:', e);
    }

    // if already started (user pressed Play before image loaded), begin reveal
    if (started) {
      revealing = true;
      revealStart = performance.now();
    }
    animate();
  };

  img.onerror = (e) => {
    console.error('Image failed to load:', img.src, e);
    // still start animate so user sees something
    // create simple fallback particles centered on canvas
    for (let i = 0; i < 90; i++) {
      const x = (Math.random() - 0.5) * 300 + canvas.width/2;
      const y = (Math.random() - 0.5) * 300 + canvas.height/2;
      particles.push(new Particle(x, y, '#34b1eb', true));
    }
    animate();
  };

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // if revealing, advance reveal animation for particles/hearts
    if (revealing && !revealDone) {
      const now = performance.now();
      let allDone = true;
      for (let p of particles) {
        const t = Math.max(0, now - revealStart - (p.revealDelay || 0));
        const prog = Math.min(1, t / revealDuration);
        // easeOutCubic
        const e = 1 - Math.pow(1 - prog, 3);
        p.baseX = p.startX + (p.targetX - p.startX) * e;
        p.baseY = p.startY + (p.targetY - p.startY) * e;
        if (prog < 1) allDone = false;
      }
      for (let h of (window._stitch && window._stitch.hearts) || []) {
        const t = Math.max(0, now - revealStart - (h.revealDelay || 0));
        const prog = Math.min(1, t / revealDuration);
        const e = 1 - Math.pow(1 - prog, 3);
        h.baseX = h.startX + (h.targetX - h.startX) * e;
        h.baseY = h.startY + (h.targetY - h.startY) * e;
        if (prog < 1) allDone = false;
      }
      if (allDone) {
        revealDone = true;
        revealing = false;
        // small pause then enable swimmers/caption fully
        setTimeout(() => { /* nothing for now; caption draws when image ready */ }, 120);
      }
    }

    // draw particles
    for (let p of particles) {
      p.update();
      p.draw();
    }

    // draw hearts if present
    if (window._stitch && window._stitch.hearts) {
      for (let h of window._stitch.hearts) {
        h.update();
        h.draw();
      }
    }

    // debug overlay: if nothing drawn, show helpful message and small preview of image
    const hasParticles = particles && particles.length > 0;
    const hasHearts = window._stitch && window._stitch.hearts && window._stitch.hearts.length > 0;
    if (!hasParticles && !hasHearts) {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '18px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Kh√¥ng c√≥ h·∫°t ho·∫∑c tr√°i tim ‚Äî ki·ªÉm tra Console (F12) ƒë·ªÉ xem l·ªói t·∫£i ·∫£nh', canvas.width/2, canvas.height/2 - 20);
      // draw small preview of image if available
      if (window._stitch && window._stitch.img && window._stitch.img.complete) {
        try {
          const previewW = Math.min(200, window._stitch.img.width);
          const previewH = (previewW / window._stitch.img.width) * window._stitch.img.height;
          ctx.globalAlpha = 0.9;
          ctx.drawImage(window._stitch.img, canvas.width/2 - previewW/2, canvas.height/2, previewW, previewH);
        } catch (e) {
          // ignore draw errors
        }
      }
      ctx.restore();
    }
  // draw caption under the scaled image (only fully visible after revealDone)
    try {
        if (window._stitch && window._stitch.img && window._stitch.img.complete) {
          const imgW = window._stitch.img.width * imgScale;
          const imgH = window._stitch.img.height * imgScale;
          const cx = canvas.width/2;
          const top = canvas.height/2 - imgH/2;
          const captionY = top + imgH + 30; // 30px below image
          // base caption (pink)
    ctx.save();
    // fade caption until reveal completes
    ctx.globalAlpha = revealDone ? 1.0 : 0.0;
    // glowing bold caption
    ctx.fillStyle = '#ff5fb0'; // pink
    ctx.font = '700 35px "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(255,95,176,0.9)';
    ctx.shadowBlur = 12;
    ctx.fillText('‚ô°awdrug‚ô°', cx, captionY);
    // slight bright outline to emphasize bold glow
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.strokeText('‚ô°awdrug‚ô°', cx, captionY);
    ctx.restore();

          // swimmers: only create and draw when explicitly activated by clicking the image
          if (window._stitch && window._stitch.swimmersVisible && !window._stitch.swimmers) {
            const glyphs = ['ìÜù ','ìÜü ','ìÜû ','ìÜù ','ìÜü '];
            const swimmers = [];
            const textWidth = ctx.measureText('‚ô°awdrug‚ô°').width;
            const startX = cx - textWidth/2 - 40;
            const endX = cx + textWidth/2 + 40;
            for (let i = 0; i < glyphs.length; i++) {
              swimmers.push({
                ch: glyphs[i],
                x: startX + (i / glyphs.length) * (endX - startX),
                y: captionY,
                // much slower swim speed (right-to-left -> negative)
                speed: -(0.06 + Math.random() * 0.12),
                // fish-like wave params
                phase: Math.random() * Math.PI * 2,
                amp: 6 + Math.random() * 6,
                freq: 0.02 + Math.random() * 0.02
              });
            }
            window._stitch.swimmers = {arr: swimmers, startX, endX};
          }

          // animate swimmers opacity toward target
          const sdata = (window._stitch && window._stitch.swimmers) ? window._stitch.swimmers : null;
          ctx.save();
          // smooth fade: move opacity ~10% of remaining difference per frame
          if (window._stitch) {
            const cur = window._stitch.swimmersOpacity || 0;
            const target = (typeof window._stitch.swimmersFadeTarget === 'number') ? window._stitch.swimmersFadeTarget : (window._stitch.swimmersVisible ? 1 : 0);
            const next = cur + (target - cur) * 0.12;
            window._stitch.swimmersOpacity = Math.max(0, Math.min(1, next));
            // if fully faded out and target is 0, mark not visible but keep swimmers array so resume continues positions
            if (window._stitch.swimmersOpacity <= 0.001 && target === 0) {
              window._stitch.swimmersVisible = false;
            }
            ctx.globalAlpha = window._stitch.swimmersOpacity || 0;
          } else {
            ctx.globalAlpha = 0;
          }
          ctx.fillStyle = '#34b1eb';
          ctx.font = '35px "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          // per-fish fade parameters
          const fadeWidth = (sdata && sdata.fadeWidth) ? sdata.fadeWidth : 60; // px
          if (sdata) for (let s of sdata.arr) {
            // update wave phase
            s.phase += s.freq;
            const yOffset = Math.sin(s.phase) * s.amp;
            // small rotation based on derivative of sine (approx)
            const rot = Math.cos(s.phase) * 0.12;

            // compute per-fish alpha: fade-out near left edge and fade-in per appearDelay
            const globalOpacity = (window._stitch && typeof window._stitch.swimmersOpacity === 'number') ? window._stitch.swimmersOpacity : 1;
            let fadeOutAlpha = 1;
            try {
              const dist = s.x - sdata.startX; // distance from left edge
              if (dist < fadeWidth) fadeOutAlpha = Math.max(0, dist / fadeWidth);
            } catch (e) { fadeOutAlpha = 1; }
            let fadeInAlpha = 1;
            try {
              const startTs = (window._stitch && window._stitch.swimmersStart) || 0;
              const elapsed = Math.max(0, performance.now() - startTs);
              const localT = Math.max(0, elapsed - (s.appearDelay || 0));
              const inDur = 350; // ms fade-in per fish
              fadeInAlpha = Math.min(1, localT / inDur);
            } catch (e) { fadeInAlpha = 1; }
            const localAlpha = fadeOutAlpha * fadeInAlpha;

            ctx.save();
            // combine global swimmers opacity with per-fish local alpha
            ctx.globalAlpha = globalOpacity * localAlpha;
            ctx.translate(s.x, s.y + yOffset);
            ctx.rotate(rot);
            ctx.fillText(s.ch, 0, 0);
            ctx.restore();

            s.x += s.speed;
            // wrap from left to right (since moving left)
            if (s.x < sdata.startX) s.x = sdata.endX;
          }
          ctx.restore();
        }
    } catch (e) {
      // ignore caption draw errors
    }

    requestAnimationFrame(animate);
  }

  // robust resize handling (debounced) using visualViewport when available to support iOS Safari
  let resizeTimer = null;
  function getViewportSize() {
    if (window.visualViewport) {
      return {w: Math.floor(window.visualViewport.width), h: Math.floor(window.visualViewport.height)};
    }
    return {w: window.innerWidth, h: window.innerHeight};
  }

  function doResize() {
    const vp = getViewportSize();
    // update canvases
    canvas.width = vp.w;
    canvas.height = vp.h;
    overlayCanvas.width = vp.w;
    overlayCanvas.height = vp.h;
    // recompute columns for overlay matrix
    cols = Math.floor(overlayCanvas.width / 16) + 1;
    drops.length = cols;
    for (let i = 0; i < cols; i++) drops[i] = Math.floor(Math.random() * overlayCanvas.height / 16);

    // reposition hearts and particles relative to new center using stored img-local coords or offsets
    if (window._stitch && window._stitch.hearts && window._stitch.img) {
      const {hearts, img} = window._stitch;
      const imgW = img.width * imgScale;
      const imgH = img.height * imgScale;
      const cx = canvas.width/2;
      const cy = canvas.height/2;
      for (let h of hearts) {
        if (h.imgX != null && h.imgY != null) {
          h.baseX = h.imgX * imgScale + cx - imgW/2;
          h.baseY = h.imgY * imgScale + cy - imgH/2;
        } else {
          // keep offset from center
          h.baseX = cx + (h.offsetX || (h.baseX - (cx))) ;
          h.baseY = cy + (h.offsetY || (h.baseY - (cy))) ;
        }
      }
      // particles
      for (let p of particles) {
        if (p.imgX != null && p.imgY != null) {
          p.baseX = p.imgX * imgScale + cx - imgW/2;
          p.baseY = p.imgY * imgScale + cy - imgH/2;
        } else {
          p.baseX = cx + (p.offsetX || (p.baseX - (cx)));
          p.baseY = cy + (p.offsetY || (p.baseY - (cy)));
        }
      }
      // swimmers: recompute caption positions so they remain under image
      if (window._stitch.swimmers && window._stitch.img) {
        const captionY = cy - imgH/2 + imgH + 30;
        const sdata = window._stitch.swimmers;
        // recompute text bounds by measuring with ctx using the current canvas size
        ctx.save();
        ctx.font = '700 22px "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
        const textWidth = ctx.measureText('‚ô°awdrug‚ô°').width;
        ctx.restore();
        const startX = cx - textWidth/2 - 40;
        const endX = cx + textWidth/2 + 40;
        sdata.startX = startX;
        sdata.endX = endX;
        // shift swimmers vertically to captionY
        for (let i = 0; i < sdata.arr.length; i++) {
          const s = sdata.arr[i];
          // keep relative fraction along the span
          const frac = (s.x - (sdata.startX)) / (sdata.endX - sdata.startX);
          s.x = startX + (frac || (i / sdata.arr.length)) * (endX - startX);
          s.y = captionY;
        }
      }
    }
  }

  function scheduleResize() {
    if (resizeTimer) clearTimeout(resizeTimer);
    resizeTimer = setTimeout(doResize, 80);
  }

  // use visualViewport events if available (better on mobile Safari)
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', scheduleResize);
    window.visualViewport.addEventListener('scroll', scheduleResize);
  }
  window.addEventListener('resize', scheduleResize);
  // run once to ensure correct sizing on load
  scheduleResize();
  
  // --- click-to-trigger: start music + show swimmers when user clicks the stitch image ---
  // Swapped the generated WebAudio melody for a simple HTMLAudioElement-based player
  // so you can supply an MP3 file. Use window.setMusicFile(url) to point to your file.

  let audioElem = null;
  let musicFileUrl = 'obito.mp3'; // set via window.setMusicFile(url)
  let isMusicPlaying = false;
  const audioVolume = 0.12; // low volume
  // swimmers fade state (0..1)
  if (!window._stitch) window._stitch = {};
  window._stitch.swimmersOpacity = window._stitch.swimmersOpacity || 0.0;
  window._stitch.swimmersFadeTarget = window._stitch.swimmersFadeTarget || 0.0;

  // initialize HTMLAudioElement player (created lazily after user gesture)
  function initAudio() {
    if (audioElem) return;
    audioElem = new Audio();
    audioElem.crossOrigin = 'anonymous';
    audioElem.loop = true;
    audioElem.volume = audioVolume;
    if (musicFileUrl) audioElem.src = musicFileUrl;
    audioElem.addEventListener('ended', () => { isMusicPlaying = false; });
  }

  // let page scripts set/change the music file URL at runtime
  window.setMusicFile = function(url) {
    musicFileUrl = url || null;
    if (audioElem) {
      try {
        audioElem.pause();
      } catch (e) {}
      audioElem.src = musicFileUrl || '';
      audioElem.load();
      audioElem.volume = audioVolume;
    }
  };

  function startMusic() {
    initAudio();
    // must be called from a user gesture (click) ‚Äî triggerMusicAndSwimmers ensures that
    if (!audioElem) return;
    audioElem.play().then(() => { isMusicPlaying = true; }).catch(e => {
      console.warn('audio play failed', e);
    });
  }

  function stopMusic() {
    // stopMusic(reset = true): if reset=false, only pause and keep currentTime so play() will resume
    function _stop(reset) {
      if (audioElem) { try { audioElem.pause(); if (reset) audioElem.currentTime = 0; } catch (e) {} }
      isMusicPlaying = false;
    }
    // backward-compatible single-arg call
    _stop(true);
  }

  // public variant that accepts reset flag
  function stopMusicReset(reset = true) {
    if (audioElem) { try { audioElem.pause(); if (reset) audioElem.currentTime = 0; } catch (e) {} }
    isMusicPlaying = false;
  }

  function ensureSwimmersExist() {
    if (!window._stitch) window._stitch = {};
    if (window._stitch.swimmers) return;
    // create swimmers under the caption (same logic as caption init)
    try {
      const glyphs = ['ìÜù','ìÜü','ìÜû','ìÜù','ìÜü'];
      const swimmers = [];
      ctx.save();
      ctx.font = '700 22px "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
      const textWidth = ctx.measureText('‚ô°awdrug‚ô°').width;
      ctx.restore();
      const cx = canvas.width/2;
      const startX = cx - textWidth/2 - 40;
      const endX = cx + textWidth/2 + 40;
      const captionY = canvas.height/2 - (img.height * imgScale)/2 + (img.height * imgScale) + 30;
      for (let i = 0; i < glyphs.length; i++) {
        swimmers.push({
          ch: glyphs[i],
          x: startX + (i / glyphs.length) * (endX - startX),
          y: captionY,
          speed: -(0.06 + Math.random() * 0.12),
          phase: Math.random() * Math.PI * 2,
          amp: 6 + Math.random() * 6,
          freq: 0.02 + Math.random() * 0.02
        });
      }
      // add per-fish appearDelay (staggered fade-in) and default fadeWidth
      const appearBase = 120; // ms between fish
      for (let i = 0; i < swimmers.length; i++) swimmers[i].appearDelay = i * appearBase;
      window._stitch.swimmers = {arr: swimmers, startX, endX, fadeWidth: 60};
    } catch (e) {
      // ignore
    }
  }

  // runtime helper to adjust per-fish fade width
  window.setSwimmerFadeWidth = function(px) {
    try {
      if (!window._stitch) window._stitch = {};
      if (!window._stitch.swimmers) ensureSwimmersExist();
      if (window._stitch.swimmers) window._stitch.swimmers.fadeWidth = Number(px) || 60;
      return window._stitch.swimmers.fadeWidth;
    } catch (e) { return null; }
  };

  function triggerMusicAndSwimmers() {
    try {
      // toggle: first click starts music + fades swimmers in; second click pauses music + fades swimmers out
      if (!window._stitch) window._stitch = {};
      const currentlyVisible = !!window._stitch.swimmersVisible;
      if (!currentlyVisible) {
        // show: if audio is paused (has currentTime > 0) resume, otherwise start
        if (audioElem && audioElem.paused && audioElem.currentTime > 0) {
          audioElem.play().then(() => { isMusicPlaying = true; }).catch(e => console.warn('resume failed', e));
        } else if (!isMusicPlaying) {
          startMusic();
        }
        window._stitch.swimmersVisible = true;
        window._stitch.swimmersFadeTarget = 1.0;
        // ensure swimmers array exists when we begin fading in
        if (!window._stitch.swimmers) ensureSwimmersExist();
  // record start time for per-fish fade-in
  window._stitch.swimmersStart = performance.now();
      } else {
        // hide: begin fade-out, pause music without resetting position so it can resume
        window._stitch.swimmersFadeTarget = 0.0;
        try { stopMusicReset(false); } catch (e) {}
      }
    } catch (e) {
      console.warn('trigger failed', e);
    }
  }

  // detect clicks on the stitch image area
  canvas.addEventListener('click', (ev) => {
    try {
      if (!img || !img.complete) return;
      const rect = canvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const imgW = img.width * imgScale;
      const imgH = img.height * imgScale;
      const dx = canvas.width/2 - imgW/2;
      const dy = canvas.height/2 - imgH/2;
      if (x >= dx && x <= dx + imgW && y >= dy && y <= dy + imgH) {
        triggerMusicAndSwimmers();
      }
    } catch (e) {}
  });
  </script>
</body>
</html>




